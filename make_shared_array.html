<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>make_shared and allocate_shared for arrays</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  </head>
  <body text="#000000" bgcolor="#ffffff" link="#0000ff" vlink="#0000ff">
    <h1><img height="86" alt="boost.png (6897 bytes)" src="../../boost.png" 
      width="277" align="middle" border="0">make_shared and allocate_shared 
      for arrays</h1>
    <p><a href="#Introduction">Introduction</a><br>
      <a href="#Synopsis">Synopsis</a><br>
      <a href="#functions">Free Functions</a><br>
      <a href="#example">Examples</a><br>
      <a href="#history">History</a><br>
      <a href="#references">References</a></p>
    <h2><a name="Introduction">Introduction</a></h2>
    <p>Originally the Boost function templates <code>make_shared</code> and 
      <code>allocate_shared</code> were for efficient allocation of shared 
      objects only. There was a need to have efficient allocation of 
      shared arrays. One criticism of class template <code>shared_array</code> 
      was always the lack of a <a href="make_shared.html">make_shared</a> 
      utility which ensures only a single allocation.</p>
    <p>The header files &lt;boost/smart_ptr/make_shared_array.hpp&gt; and 
      &lt;boost/smart_ptr/allocate_shared_array.hpp&gt; provide function 
      templates, overloads of <code>make_shared</code> and 
      <code>allocate_shared</code> for array types, to address this need. 
      <code>make_shared</code> uses the global operator <code>new</code> to 
      allocate memory, whereas <code>allocate_shared</code> uses an 
      user-supplied allocator, allowing finer control.</p>
    <h2><a name="Synopsis">Synopsis</a></h2>
    <pre>namespace boost {
    template&lt;typename U&gt; // U is T[]
    shared_ptr&lt;U&gt; <a href="#functions">make_shared</a>(size_t size);

    template&lt;typename U, typename A&gt; // U is T[]
    shared_ptr&lt;U&gt; <a href="#functions">allocate_shared</a>(const A&amp; allocator, size_t size);
    
    template&lt;typename U&gt; // U is T[N]
    shared_ptr&lt;U&gt; <a href="#functions">make_shared</a>();

    template&lt;typename U, typename A&gt; // U is T[N]
    shared_ptr&lt;U&gt; <a href="#functions">allocate_shared</a>(const A&amp; allocator);
   
    template&lt;typename U&gt; // U is T[]
    shared_ptr&lt;U&gt; <a href="#functions">make_shared</a>(size_t size, const T&amp; value);

    template&lt;typename U, typename A&gt; // U is T[]
    shared_ptr&lt;U&gt; <a href="#functions">allocate_shared</a>(const A&amp; allocator, size_t size, const T&amp; value);

    template&lt;typename U&gt; // U is T[N]
    shared_ptr&lt;U&gt; <a href="#functions">make_shared</a>(const T&amp; value);

    template&lt;typename U, typename A&gt; // U is T[N]
    shared_ptr&lt;U&gt; <a href="#functions">allocate_shared</a>(const A&amp; allocator, const T&amp; value);

    template&lt;typename U&gt; // U is T[]
    shared_ptr&lt;U&gt; <a href="#functions">make_shared_noinit</a>(size_t size);

    template&lt;typename U, typename A&gt; // U is T[]
    shared_ptr&lt;U&gt; <a href="#functions">allocate_shared_noinit</a>(const A&amp; allocator, size_t size);

    template&lt;typename U&gt; // U is T[N]
    shared_ptr&lt;U&gt; <a href="#functions">make_shared_noinit</a>();

    template&lt;typename U, typename A&gt; // U is T[N]
    shared_ptr&lt;U&gt; <a href="#functions">allocate_shared_noinit</a>(const A&amp; allocator);
}</pre>
    <h2><a name="functions">Free Functions</a></h2>
    <pre>template&lt;typename U&gt; // U is T[]
shared_ptr&lt;U&gt; make_shared(size_t size);

template&lt;typename U, typename A&gt; // U is T[]
shared_ptr&lt;U&gt; allocate_shared(const A&amp; allocator, size_t size);

template&lt;typename U&gt; // U is T[N]
shared_ptr&lt;U&gt; make_shared();

template&lt;typename U, typename A&gt; // U is T[N]
shared_ptr&lt;U&gt; allocate_shared(const A&amp; allocator);</pre> 
    <blockquote>
      <p><b>Requires:</b> The expression 
        <code>new(pointer) T()</code>, where <code>pointer</code> is a 
        <code>void*</code> pointing to storage suitable to hold an object of 
        type <code>T</code>, shall be well-formed. <code>A</code> shall be an 
        <em>Allocator</em>, as described in section 20.1.5 (<strong>Allocator 
        requirements</strong>) of the C++ Standard. The copy constructor and 
        destructor of <code>A</code> shall not throw.</p>
      <p><b>Effects:</b> Allocates memory suitable for an array of type 
        <code>T</code> and size <code>size</code> and constructs an array of 
        objects in it via the placement new expression <code>new(pointer) 
        T()</code>. <code>allocate_shared</code> uses a copy of 
        <code>allocator</code> to allocate memory. If an exception is thrown, 
        has no effect.</p>
      <p><b>Returns:</b> A <code>shared_ptr</code> instance that stores and 
        owns the address of the newly constructed array of type <code>T</code> 
        and size <code>size</code>.</p>
      <p><b>Postconditions:</b> 
        <code>get() != 0 &amp;&amp; use_count() == 1</code>.</p>
      <p><b>Throws:</b> <code>bad_alloc</code>, or an exception thrown from 
        <code>A::allocate</code> or the constructor of <code>T</code>.</p>
      <p><b>Notes:</b> This implementation allocates the memory required for 
        the returned <code>shared_ptr</code> and an array of type 
        <code>T</code> of size <code>size</code> in a single allocation. This 
        provides efficiency to equivalent to an intrusive smart pointer.</p>
    </blockquote>
    <pre>template&lt;typename U&gt; // U is T[]
shared_ptr&lt;U&gt; make_shared(size_t size, const T&amp; value);

template&lt;typename U, typename A&gt; // U is T[]
shared_ptr&lt;U&gt; allocate_shared(const A&amp; allocator, size_t size, const T&amp; value);

template&lt;typename U&gt; // U is T[N]
shared_ptr&lt;U&gt; make_shared(const T&amp; value);

template&lt;typename U, typename A&gt; // U is T[N]
shared_ptr&lt;U&gt; allocate_shared(const A&amp; allocator, const T&amp; value);</pre>
    <blockquote>
      <p><b>Notes:</b> These overloads initialize array objects with the given 
        value.</p>
    </blockquote>
    <pre>template&lt;typename U&gt; // U is T[]
shared_ptr&lt;U&gt; make_shared_noinit(size_t size);

template&lt;typename U, typename A&gt; // U is T[]
shared_ptr&lt;U&gt; allocate_shared_noinit(const A&amp; allocator, size_t size);

template&lt;typename U&gt; // U is T[N]
shared_ptr&lt;U&gt; make_shared_noinit();

template&lt;typename U, typename A&gt; // U is T[N]
shared_ptr&lt;U&gt; allocate_shared_noinit(const A&amp; allocator);</pre>
    <blockquote>
      <p><b>Notes:</b> These overloads do not perform value initialization of 
        array objects.</p>
    </blockquote>    
    <h2><a name="example">Examples</a></h2>
    <p>The following examples value-initialize objects.</p>
    <blockquote>
      <pre>boost::shared_ptr&lt;int[]&gt;     a1  = boost::make_shared&lt;int[]&gt;(size);
boost::shared_ptr&lt;int[8]&gt;    a2  = boost::make_shared&lt;int[8]&gt;();
boost::shared_ptr&lt;int[][2]&gt;  a3  = boost::make_shared&lt;int[][2]&gt;(size);
boost::shared_ptr&lt;int[4][2]&gt; a4  = boost::make_shared&lt;int[4][2]&gt;();</pre>
    </blockquote>
    <p>The following examples initialize objects with a given value.</p>
    <blockquote>
      <pre>boost::shared_ptr&lt;int[]&gt;     a5  = boost::make_shared&lt;int[]&gt;(size, 1);
boost::shared_ptr&lt;int[8]&gt;    a6  = boost::make_shared&lt;int[8]&gt;(1);
boost::shared_ptr&lt;int[][2]&gt;  a7  = boost::make_shared&lt;int[][2]&gt;(size, {1, 2});
boost::shared_ptr&lt;int[4][2]&gt; a8  = boost::make_shared&lt;int[4][2]&gt;({1, 2});</pre>
    </blockquote>
    <p>The following examples default-initialize objects.</p>
    <blockquote>
      <pre>boost::shared_ptr&lt;int[]&gt;     a9  = boost::make_shared_noinit&lt;int[]&gt;(size);
boost::shared_ptr&lt;int[8]&gt;    a10 = boost::make_shared_noinit&lt;int[8]&gt;();
boost::shared_ptr&lt;int[][2]&gt;  a11 = boost::make_shared_noinit&lt;int[][2]&gt;(size);
boost::shared_ptr&lt;int[4][2]&gt; a12 = boost::make_shared_noinit&lt;int[4][2]&gt;();</pre>
    </blockquote>
    <h2><a name="history">History</a></h2>
    <p>January 2014. Glen Fernandes reduced the overloads of make_shared and 
      allocate_shared according to <a href="#N3870">N3870</a>.</p>
    <p>November 2012. Glen Fernandes contributed implementations of 
      make_shared and allocate_shared for arrays.</p>
    <h2><a name="references">References</a></h2>
    <p><a name="N3870">N3870</a>,
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3870.html">
      Extending make_shared to Support Arrays, Revision 1</a>, Peter Dimov 
      &amp; Glen Fernandes, January, 2014.</p>
    <hr>
    <p>$Date: 2014-01-20 11:10:00 -0800 (Mon, 20 Jan 2014) $</p>
    <p><small>Copyright 2012-2014 Glen Fernandes. Distributed under the 
      Boost Software License, Version 1.0. See accompanying file 
      <a href="../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at 
      <a href="http://www.boost.org/LICENSE_1_0.txt">
      http://www.boost.org/LICENSE_1_0.txt</a>.</small></p>
  </body>
</html>
